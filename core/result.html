<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 2.0.10">
<title>Result API</title>
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700">
<link rel="stylesheet" href="./asciidoctor.css">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
</head>
<body class="book toc2 toc-left">
<div id="header">
<div id="toc" class="toc2">
<div id="toctitle">Table of Contents</div>
<ul class="sectlevel2">
<li><a href="#_result_api">1. Result API</a></li>
</ul>
</div>
</div>
<div id="content">
<div class="sect2">
<h3 id="_result_api"><a class="anchor" href="#_result_api"></a>1. Result API</h3>
<div class="paragraph">
<p>With the Result API Rico offers the functionality to define results of computations that may either result in an exception, or return a successfully computed value.
When using for example the stream API of Java one critical topic that is often ignored is the exception handling.
The following code shows a bad example of a stream handling that will end in an error:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="predefined-type">List</span>&lt;<span class="predefined-type">Result</span>&gt; results = Stream.of(<span class="string"><span class="delimiter">&quot;</span><span class="content">1</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">TWO</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">3</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">4</span><span class="delimiter">&quot;</span></span>)
                        .map(<span class="predefined-type">Integer</span>::valueOf)
                        .collect(Collectors.toList());</code></pre>
</div>
</div>
<div class="paragraph">
<p>This code will throw an exception at runtime once the second input value (<code>TWO</code>) will be mapped by the given <code>Function</code> (<code>Integer:valueOf</code>).
All values that will be provided by the stream after the second value will never be mapped.
If we now assume that the mapping function will send a mail instead of just parsing a number we will end in big trouble.
Once the exception has been thrown we have zero knowledge about the state of our system.
We do not know how many elements were mapped successfully and for how many elements the mapping never happened.
If the stream will be handled in parallel things might even become worse.</p>
</div>
<div class="paragraph">
<p>Here the Result API of Rico comes into play.
The API provides functionality to handle successful and failed results of calculations like a mapping.
The <code>dev.rico.core.functional.Result</code> provides several factory methods that can be used to create a result.
The following code snippet gives an example how the Result API can be used:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="predefined-type">List</span>&lt;<span class="predefined-type">Result</span>&gt; results = Stream.of(<span class="string"><span class="delimiter">&quot;</span><span class="content">1</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">TWO</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">3</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">4</span><span class="delimiter">&quot;</span></span>)
                        .map(<span class="predefined-type">Result</span>.of(<span class="predefined-type">Integer</span>::valueOf))
                        .collect(Collectors.toList());</code></pre>
</div>
</div>
<div class="paragraph">
<p>In the given example the mapper wil be executed for all elements of the stream.
Each mapping will end in a <code>dev.rico.core.functional.Result</code> instance that is either successful or failed.
For the input "TWO" the mapping will result in a failed <code>dev.rico.core.functional.Result</code>.</p>
</div>
<div class="paragraph">
<p>If a result is successful or failed can be checked by calling <code>isSuccessful()</code> or <code>isFailed()</code>.
If a result is successful calling the <code>getResult()</code> method will return the wrapped return value of the original calculation.
For a failed result the <code>getResult()</code> method will always throw an <code>IllegalStateException</code>.
Next to this <code>getException()</code> can be called to receive the exception thrown by the original calculation.
For a successful result this will always throw an <code>IllegalStateException</code>.</p>
</div>
<div class="paragraph">
<p>The following snippet shows a possible use-case of the API:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="predefined-type">List</span>&lt;<span class="predefined-type">Result</span>&lt;<span class="predefined-type">Integer</span>&gt;&gt; results = Stream.of(<span class="string"><span class="delimiter">&quot;</span><span class="content">1</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">TWO</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">3</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">4</span><span class="delimiter">&quot;</span></span>)
                        .map(<span class="predefined-type">Result</span>.of(<span class="predefined-type">Integer</span>::valueOf))
                        .collect(Collectors.toList());

results.stream().filter(r -&gt; r.isFailed())
                .forEach(r -&gt; <span class="predefined-type">System</span>.out.println(<span class="string"><span class="delimiter">&quot;</span><span class="content">Error when parsing Integer</span><span class="delimiter">&quot;</span></span>));</code></pre>
</div>
</div>
<div class="paragraph">
<p>For a better result handling several of the factory methods of the <code>dev.rico.core.functional.Result</code> interface return a  <code>dev.rico.core.functional.ResultWithInput</code>.
This interface extends the <code>dev.rico.core.functional.Result</code> and adds the possibility to access the input value of the origin calculation.
With the additional functionality our sample will look like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="predefined-type">List</span>&lt;ResultWithInput&lt;<span class="predefined-type">String</span>, <span class="predefined-type">Integer</span>&gt;&gt; results = Stream.of(<span class="string"><span class="delimiter">&quot;</span><span class="content">1</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">TWO</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">3</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">4</span><span class="delimiter">&quot;</span></span>)
                        .map(<span class="predefined-type">Result</span>.of(<span class="predefined-type">Integer</span>::valueOf))
                        .collect(Collectors.toList());

results.stream().filter(r -&gt; r.isFailed())
                .forEach(r -&gt; <span class="predefined-type">System</span>.out.println(<span class="string"><span class="delimiter">&quot;</span><span class="content">Error when parsing </span><span class="delimiter">&quot;</span></span> + r.getInput()));</code></pre>
</div>
</div>
<div class="paragraph">
<p>Instead of extracting the content of the result you can register callbacks which are executed in case of success or failure.</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>Result&lt;U&gt; map(CheckedFunction&lt;R, U&gt;)</code></p>
</li>
<li>
<p><code>Result&lt;R&gt; recover(CheckedFunction&lt;Exception, R&gt;</code></p>
</li>
<li>
<p><code>Result&lt;R&gt; recover(CheckedBiFunction&lt;V, Exception, R&gt;</code></p>
</li>
<li>
<p><code>Result&lt;Void&gt; onSuccess(CheckedConsumer&lt;R&gt;)</code></p>
</li>
<li>
<p><code>Result&lt;Void&gt; onSuccess(CheckedRunnable)</code></p>
</li>
<li>
<p><code>void onFailure(Consumer&lt;Exception&gt;)</code></p>
</li>
<li>
<p><code>void onFailure(BiConsumer&lt;V, Exception&gt;)</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>There is one more convenience method <code>orElse&#174;</code> which allows to get a default value in case of a failed result.</p>
</div>
</div>
</div>
<div id="footer">
<div id="footer-text">
Version 2.1.0-SNAPSHOT<br>
Last updated 2021-06-25 06:18:42 UTC
</div>
</div>
<link rel="stylesheet" href="./coderay-asciidoctor.css">
</body>
</html>